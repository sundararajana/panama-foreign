/*
 * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

// Generated by jextract and then hand-edited to avoid ConstantsHelper class

package jdk.internal.foreign.jimage;

import java.lang.invoke.MethodHandle;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.CSupport.*;

public final class jimage_h {

    private static class Constants {
         static final FunctionDescriptor JIMAGE_ResourceIterator$visitor$DESC = FunctionDescriptor.of(
                 C_INT, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER);

         static final MethodHandle JIMAGE_Open$MH = RuntimeHelper.downcallHandle(
                new LibraryLookup[0], "JIMAGE_Open",
                "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER), false);

         static final MethodHandle JIMAGE_Close$MH = RuntimeHelper.downcallHandle(
                 new LibraryLookup[0], "JIMAGE_Close",
                 "(Ljdk/incubator/foreign/MemoryAddress;)V",
                 FunctionDescriptor.ofVoid(C_POINTER), false);

         static final MethodHandle JIMAGE_PackageToModule$MH = RuntimeHelper.downcallHandle(
                 new LibraryLookup[0], "JIMAGE_PackageToModule",
                 "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
                 FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER), false);

         static final MethodHandle JIMAGE_FindResource$MH = RuntimeHelper.downcallHandle(
                 new LibraryLookup[0], "JIMAGE_FindResource",
                 "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)J",
                 FunctionDescriptor.of(C_LONGLONG, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER), false);

         static final MethodHandle JIMAGE_GetResource$MH = RuntimeHelper.downcallHandle(
                 new LibraryLookup[0], "JIMAGE_GetResource",
                 "(Ljdk/incubator/foreign/MemoryAddress;JLjdk/incubator/foreign/MemoryAddress;J)J",
                 FunctionDescriptor.of(C_LONGLONG, C_POINTER, C_LONGLONG, C_POINTER, C_LONGLONG), false);

         static final MethodHandle JIMAGE_ResourceIterator$MH = RuntimeHelper.downcallHandle(
                 new LibraryLookup[0], "JIMAGE_ResourceIterator",
                 "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
                 FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER), false);
    }

    private jimage_h() {}
    public static int JIMAGE_MAX_PATH() {
        return 4096;
    }

    public static int JIMAGE_NOT_FOUND() {
        return 0;
    }

    public static int JIMAGE_BAD_MAGIC() {
        return -1;
    }

    public static int JIMAGE_BAD_VERSION() {
        return -2;
    }
  
    public static int JIMAGE_CORRUPTED() {
        return -3;
    }

    public static MethodHandle JIMAGE_Open$MH() {
        return Constants.JIMAGE_Open$MH;
    }

    public static MemoryAddress JIMAGE_Open (MemoryAddress name, MemoryAddress error) {
        try {
            return (MemoryAddress) JIMAGE_Open$MH().invokeExact(name, error);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public static MethodHandle JIMAGE_Close$MH() {
        return Constants.JIMAGE_Close$MH;
    }

    public static void JIMAGE_Close (MemoryAddress jimage) {
        try {
            JIMAGE_Close$MH().invokeExact(jimage);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public static MethodHandle JIMAGE_PackageToModule$MH() {
        return Constants.JIMAGE_PackageToModule$MH;
    }

    public static MemoryAddress JIMAGE_PackageToModule (MemoryAddress jimage, MemoryAddress package_name) {
        try {
            return (MemoryAddress) JIMAGE_PackageToModule$MH().invokeExact(jimage, package_name);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public static MethodHandle JIMAGE_FindResource$MH() {
        return Constants.JIMAGE_FindResource$MH;
    }

    public static long JIMAGE_FindResource (MemoryAddress jimage, MemoryAddress module_name, MemoryAddress version,
                                            MemoryAddress name, MemoryAddress size) {
        try {
            return (long) JIMAGE_FindResource$MH().invokeExact(jimage, module_name, version, name, size);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public static MethodHandle JIMAGE_GetResource$MH() {
        return Constants.JIMAGE_GetResource$MH;
    }

    public static long JIMAGE_GetResource (MemoryAddress jimage, long location, MemoryAddress buffer, long size) {
        try {
            return (long) JIMAGE_GetResource$MH().invokeExact(jimage, location, buffer, size);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public static MethodHandle JIMAGE_ResourceIterator$MH() {
        return Constants.JIMAGE_ResourceIterator$MH;
    }

    public static void JIMAGE_ResourceIterator (MemoryAddress jimage, MemoryAddress visitor, MemoryAddress arg) {
        try {
            JIMAGE_ResourceIterator$MH().invokeExact(jimage, visitor, arg);
        } catch (Throwable ex) {
            throw new AssertionError(ex);
        }
    }

    public interface JIMAGE_ResourceIterator$visitor {
        int apply(MemoryAddress x0, MemoryAddress x1, MemoryAddress x2, MemoryAddress x3,
                  MemoryAddress x4, MemoryAddress x5, MemoryAddress x6);

        public static MemorySegment allocate(JIMAGE_ResourceIterator$visitor fi) {
            return RuntimeHelper.upcallStub(JIMAGE_ResourceIterator$visitor.class, fi, Constants.JIMAGE_ResourceIterator$visitor$DESC,
                    "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I");
        }

        public static MemoryAddress allocate(JIMAGE_ResourceIterator$visitor fi, NativeScope scope) {
            return scope.register(allocate(fi)).baseAddress();
        }
    }
}


